#!/bin/sh 

PREREQS=""
prereqs()
{
    echo $PREREQS
}

case $1 in
    prereqs)
        exit 0
        ;;
esac

if [ -e /scripts/functions ];then
    . /scripts/functions
fi

os_name=""
if uname -a | grep "Debian" > /dev/null 2>&1;then
    os_name="debian"
fi
if uname -a | grep "Arch" > /dev/null 2>&1;then
    os_name="archlinux"
fi


sfs_part=""
unionfs_part=""
home_part=""
work_part=""
backup_part=""

label_suffix=""

sfs_show=false
unionfs_show=true

root_mem_size=0
home_mem_size=0

zm_dir=""
zm_kernel=""
zm_save="no"
zm_debug=false

root_file=""
home_file=""
unionfs_min_size=1024

#mount path
sfs_part_mpath=/media/sfsroot
sfs_mpath=/media/sfs
unionfs_mpath=/media/unionfs
sfs_root_mpath=$sfs_mpath/root
sfs_home_mpath=$sfs_mpath/home
unionfs_root_mpath=""
unionfs_home_mpath=""
unionfs_clean_file=.union.fs.clean

case "$os_name" in
    debian)
        new_root=/root
        ;;
    archlinux)
        new_root=/new_root
        ;;
esac
root_mpath=/
home_mpath=/home
work_mpath=/work
backup_mpath=/media/backup

home_mounted=false
work_mounted=false
backup_mounted=false
unionfs_part_mounted=false
unionfs_root_mounted=false
unionfs_home_mounted=false

unionfs_max_branch=8
cpu_counts=$(cat /proc/cpuinfo | grep "processor" | wc -l)
KERNEL_VERSION=$(uname -r | awk  -F '-' 'BEGIN{OFS="."}{print $1}' | awk  -F '.' 'BEGIN{OFS="."}{print $1,$2,$3}')

get_linux_kernel_code()  
{  
    #expr $(VERSION) \* 65536 + 0$(PATCHLEVEL) \* 256 + 0$(SUBLEVEL));  
    VERSION=`echo $1 | awk  -F '.' 'BEGIN{OFS="."}{print $1}'`  
    PATCHLEVEL=`echo $1 | awk  -F '.' 'BEGIN{OFS="."}{print $2}'`  
    SUBLEVEL=`echo $1 | awk  -F '.' 'BEGIN{OFS="."}{print $3}'`  
    #echo $VERSION  
    #echo $PATCHLEVEL  
    #echo $SUBLEVEL  
    KERNEL_CODE=`expr $VERSION \* 65536 + 0$PATCHLEVEL \* 256 + 0$SUBLEVEL`  
    return $KERNEL_CODE  
} 

debug_var()
{
    var=$1
    eval value='$'$var
    printf "  %-15s : %-s\n" $var $value
}

print_param_info()
{
    debug_var sfs_part
    debug_var unionfs_part
    debug_var home_part
    debug_var work_part
    debug_var backup_part
    debug_var root_mem_size
    debug_var home_mem_size
    debug_var unionfs_min_size
    debug_var root_file
    debug_var home_file
}

err_exit()
{
    print_param_info
    panic $@
}

print_msg()
{
    echo $@ > /dev/console
}

goto_shell()
{
    print_msg "$@"
    print_msg "Goto shell, and prees ctrl + d to continue."

    case "$os_name" in
        debian)
            PS1='[zm:initramfs] ' /bin/sh -i </dev/console >/dev/console 2>&1
            true
            ;;
        archlinux)
            launch_interactive_shell
            ;;
    esac
}

get_filesize_mb()
{
    test -e "$1" || err_exit "$1 is no exist!"
    fileSizeB=`stat -c %s $1`
    fileSizeKB=`expr $fileSizeB / 1024`
    fileSizeMB=`expr $fileSizeKB / 1024`
    echo $fileSizeMB
}

get_mem_freesize_mb()
{
    all_free_size=$(free -m | grep Mem | awk '{print $4}')
    expr $all_free_size - 512
}

get_freesize_dir_mb()
{
    size_mb=$(df -mP $1 | sed -n '2p' | awk '{print $4}')
    echo ${size_mb}
}

get_freesize_path()
{
    min_size=$1; shift
    all_path=$@

    free_path=""
    for path in $all_path
    do
        if [ "$(get_freesize_dir_mb $path)" -gt $min_size ];then
            free_path=$path
        fi
        if [ -n "$free_path" ];then
            break
        fi
    done
    echo $free_path
}

mount_storage()
{
    mount_src=$1
    mount_point=$2
    if [ -b "$mount_src" ];then
        print_msg "Check filesystem on $mount_src ..."
        checkfs $mount_src $mount_point
    fi
    print_msg "Mounting $mount_src on $mount_point ..."
    mkdir -p -m 0755 $mount_point
    mount $mount_src $mount_point || err_exit "mount $@ error"
}

mount_move()
{
    old_mpath=$1
    new_mpath=$2/$1

    mkdir -p -m 0755 $new_mpath
    mount -n -o move $old_mpath $new_mpath || err_exit "mount move $old_mpath $new_mpath error"
}

init_params()
{
    for x in $(cat /proc/cmdline); do
        case $x in
            sfs_part=*)
                sfs_part=${x#sfs_part=}
                ;;
            unionfs_part=*)
                unionfs_part=${x#unionfs_part=}
                ;;
            label_suffix=*)
                label_suffix=${x#label_suffix=}
                ;;
            root_mem_size=*)
                root_mem_size=${x#root_mem_size=}
                ;;
            home_mem_size=*)
                home_mem_size=${x#home_mem_size=}
                ;;
            zm_dir=*)
                zm_dir=${x#zm_dir=}
                ;;
            home_part=*)
                home_part=${x#home_part=}
                ;;
            work_part=*)
                work_part=${x#work_part=}
                ;;
            backup_part=*)
                backup_part=${x#backup_part=}
                ;;
            BOOT_IMAGE=*)
                zm_kernel=${x#BOOT_IMAGE=}
                ;;
            zm_save=*)
                zm_save=${x#zm_save=}
                ;;
            debug)
                zm_debug=true
                set -x
                ;;
        esac
    done

    case $sfs_part in 
        cdrom|/dev/sr*)
            if [ $sfs_part = "cdrom" ];then
                sfs_part=/dev/sr0
            fi
            ;;
        *)
            ;;
    esac

    in_virtual_machine="no"
    if cat /proc/cpuinfo | grep 'model name' | grep -i -E 'kvm|qemu|virtual' > /dev/null;then
        in_virtual_machine="yes"
    fi
    all_mem_size=$(free -g | grep Mem | awk '{print $2}')

    if [ -z "$zm_kernel" ];then
        err_exit "Not find kernel param in cmdline."
    fi

    if [ -z "$zm_dir" ];then
        zm_dir=$(dirname $zm_kernel)
    fi

    free_mem_size=$(get_mem_freesize_mb) 
    if [ "$free_mem_size" -gt "$unionfs_min_size" ];then
        test $root_mem_size = 0 && root_mem_size=$free_mem_size
        test $home_mem_size = 0 && home_mem_size=$free_mem_size
    fi
}

wait_sfspart()
{
    wait_time=$1
    test -z "$wait_time" && wait_time=5
    for i in `seq 1 $wait_time`;do
        if [ -b $sfs_part ];then
            return 0
        fi
        sleep 1
    done
    return 1
}

init_sfs()
{
    modprobe isofs 
    modprobe ext2 
    modprobe ext3 
    modprobe ext4 
    modprobe squashfs
    # modprobe vfat 
    # modprobe ntfs

    test -n "$sfs_part" && sfs_part=$(resolve_device $sfs_part)
    test -n "$unionfs_part" && unionfs_part=$(resolve_device $unionfs_part)
    test -n "$home_part" && home_part=$(resolve_device $home_part)
    test -n "$work_part" && work_part=$(resolve_device $work_part)
    test -n "$backup_part" && backup_part=$(resolve_device $backup_part)

    test -n "$sfs_part" || sfs_part="/dev/disk/by-label/sfsroot$label_suffix"
    test -n "$unionfs_part" || unionfs_part="/dev/disk/by-label/unionfs$label_suffix"
    test -n "$home_part" || home_part="/dev/disk/by-label/home$label_suffix"
    test -n "$work_part" || work_part="/dev/disk/by-label/work$label_suffix"
    test -n "$backup_part" || backup_part="/dev/disk/by-label/backup$label_suffix"

    if ! wait_sfspart;then
        sfs_part=$(ls /dev/disk/by-label/sfsroot_* 2> /dev/null)
        if [ -n "$sfs_part" ];then
            label=$(basename $sfs_part)
            label_suffix=${label/sfsroot}
            unionfs_part="/dev/disk/by-label/unionfs$label_suffix"
            home_part="/dev/disk/by-label/home$label_suffix"
            work_part="/dev/disk/by-label/work$label_suffix"
            backup_part="/dev/disk/by-label/backup$label_suffix"
        fi
    fi

    if ! wait_sfspart 1;then
        test -b "$sfs_part" || sfs_part="/dev/disk/by-label/sfsroot$label_suffix"
        test -b "$unionfs_part" || unionfs_part="/dev/disk/by-label/unionfs$label_suffix"
        test -b "$home_part" || home_part="/dev/disk/by-label/home$label_suffix"
        test -b "$work_part" || work_part="/dev/disk/by-label/work$label_suffix"
        test -b "$backup_part" || backup_part="/dev/disk/by-label/backup$label_suffix"
    fi

    if ! wait_sfspart 1;then
        err_exit "no sfs partiton"
    fi

    mount_storage $sfs_part $sfs_part_mpath

    root_sfs="$zm_dir/root.sfs"
    home_sfs="$zm_dir/home.sfs"
    root_file=$(readlink -f $sfs_part_mpath/${root_sfs} || true)
    home_file=$(readlink -f $sfs_part_mpath/${home_sfs} || true)
    test -e "$root_file" || err_exit "Not found root sfs file!"

    if [ -b "$work_part" ];then
        mount_storage $work_part $work_mpath && work_mounted=true
    fi
    if [ -b "$backup_part" ];then
        mount_storage $backup_part $backup_mpath && backup_mounted=true
    fi

    if [ -b $unionfs_part ];then
        mkdir -p -m 0755 $unionfs_mpath
        mount_storage $unionfs_part $unionfs_mpath && unionfs_part_mounted=true
        unionfs_root_mpath=$unionfs_mpath/unionfs/root
        unionfs_home_mpath=$unionfs_mpath/unionfs/home
        mkdir -p -m 0755 $unionfs_root_mpath
        mkdir -p -m 0755 $unionfs_home_mpath
    else
        if [ "$zm_save" = "yes" -o $(get_mem_freesize_mb) -lt $unionfs_min_size ];then
            unionfs_path=$(get_freesize_path $unionfs_min_size $sfs_part_mpath)
            test -z "$unionfs_path" && err_exit "Can't get unionfs space."

            unionfs_root_mpath=$unionfs_path/unionfs/root
            unionfs_home_mpath=$unionfs_path/unionfs/home
            mkdir -p -m 0755 $unionfs_root_mpath
            mkdir -p -m 0755 $unionfs_home_mpath
            if [ $zm_save != "yes" ];then
                touch ${unionfs_root_mpath}/$unionfs_clean_file
                touch ${unionfs_home_mpath}/$unionfs_clean_file
            fi
        fi
    fi
}

# mount_with_aufs root /media/sfsroot/linux/amd64/zm /media/sfs /media/union_fs/ /root/
__mount_with_aufs()
{
    sfsname="$1"
    sfsdir="$2"
    sfsmountdir=$3
    upperdir="$4"
    mountdir="$5"

    test -d "$upperdir" || err_exit "upperdir: $upperdir is not found!"
    test -d "$mountdir" || err_exit "mountdir: $mountdir is not found!"

    sfsfile=$(readlink -f "${sfsdir}/${sfsname}.sfs")
    test -f "$sfsfile" || err_exit "sfsfile: ${sfsdir}/${sfsname}.sfs is not found!"

    if [ -e "${upperdir}/$unionfs_clean_file" ];then
        rm -rf ${upperdir}/{*,.[!.]*,..?*}
    fi

    sfsmpath=$sfsmountdir/$sfsname
    mount_storage $sfsfile $sfsmpath
    mount -t aufs -o br:$upperdir none $mountdir
    mount -t aufs -o remount,udba=none,append:${sfsmpath}=ro none $mountdir
    for branch in $(seq 1 $unionfs_max_branch)
    do
        if [ -e "${sfsfile}.${branch}" ];then
            mount_storage ${sfsfile}.${branch} ${sfsmpath}.${branch}
            mount -t aufs -o remount,udba=none,add:1:${sfsmpath}.${branch}=ro+wh none $mountdir
            continue
        fi
        break
    done
}

__mount_with_overlay()
{
    sfsname="$1"
    sfsdir="$2"
    sfsmountdir=$3
    upperdir="$4"
    mountdir="$5"


    test -d "$upperdir" || err_exit "upperdir: $upperdir is not found!"
    test -d "$mountdir" || err_exit "mountdir: $mountdir is not found!"

    sfsfile=$(readlink -f "${sfsdir}/${sfsname}.sfs")
    test -f "$sfsfile" || err_exit "sfsfile: ${sfsdir}/${sfsname}.sfs is not found!"

    if [ -e "${upperdir}/$unionfs_clean_file" ];then
        rm -rf ${upperdir}/{*,.[!.]*,..?*}
    fi

    lowerdir=""
    set_lowerdir()
    {
        if [ -z "$lowerdir" ];then
            lowerdir=$@
        else
            lowerdir=$@:${lowerdir}
        fi
    }

    sfsmpath=$sfsmountdir/$sfsname
    mount_storage $sfsfile $sfsmpath
    for branch in $(seq 1 $unionfs_max_branch)
    do
        if [ -e "${sfsfile}.${branch}" ];then
            mount_storage ${sfsfile}.${branch} ${sfsmpath}.${branch}
            set_lowerdir ${sfsmpath}.${branch}
            continue
        fi
        break
    done

    set_lowerdir ${sfsmpath}
    debug_var $lowerdir

    mkdir -p -m 0755 $upperdir/upper
    mkdir -p -m 0755 $upperdir/work
    options="lowerdir=$lowerdir,upperdir=$upperdir/upper,workdir=$upperdir/work"
    mount -t overlay -o $options overlay $mountdir
}

mount_unionfs()
{
    if modprobe overlay > /dev/null 2>&1;then
        __mount_with_overlay $@
    elif modprobe aufs > /dev/null 2>&1;then
        __mount_with_aufs $@
    else
        echo "no support union filesystem."
        return 1
    fi
}

mount_root()
{
    if [ -z "$unionfs_root_mpath" ];then
        test $root_mem_size -gt $unionfs_min_size || err_exit "root_mem_size less len unionfs_min_size"
        unionfs_root_mpath=$unionfs_mpath/root
        mkdir -p -m 0755 $unionfs_root_mpath
        mount -t tmpfs -o mode=755,size=${root_mem_size}m none $unionfs_root_mpath && unionfs_root_mounted=true
    fi
    mount_unionfs root $sfs_part_mpath/$zm_dir $sfs_mpath $unionfs_root_mpath ${new_root}/$root_mpath
}

mount_home()
{

    if [ -b "$home_part" ];then
        mount_storage $home_part $home_mpath && home_mounted=true
        return
    fi

    if [ ! -e "$home_file" ];then
        goto_shell "home file is not found, maybe start with error, please check again." 
    fi

    if [ -z "$unionfs_home_mpath" ];then
        test $home_mem_size -gt $unionfs_min_size || err_exit "home_mem_size less then unionfs_min_size"
        unionfs_home_mpath=$unionfs_mpath/home
        mkdir -p -m 0755 $unionfs_home_mpath
        mount -t tmpfs -o mode=755,size=${home_mem_size}m none $unionfs_home_mpath && unionfs_home_mounted=true
    fi

    mount_unionfs home $sfs_part_mpath/$zm_dir $sfs_mpath $unionfs_home_mpath ${new_root}/$home_mpath
}

swap_file() 
{
    chmod 600 $1
    mkswap $1
    swapon $1
}

mount_swap()
{
    if [ -b /dev/disk/by-label/swap$label_suffix ];then
        swapon LABEL=swap$label_suffix
    fi
}

move_to_newroot()
{
    mount_move $sfs_part_mpath ${new_root}

    $home_mounted && mount_move $home_mpath ${new_root}
    $work_mounted && mount_move $work_mpath ${new_root}
    $backup_mounted && mount_move $backup_mpath ${new_root}
    $unionfs_part_mounted && mount_move $unionfs_mpath ${new_root}

    if $unionfs_show;then
        $unionfs_root_mounted && mount_move $unionfs_root_mpath ${new_root}
        $unionfs_home_mounted && mount_move $unionfs_home_mpath ${new_root}
    fi

    if $sfs_show;then
        mount_move $sfs_root_mpath ${new_root}
        for branch in $(seq 1 $unionfs_max_branch)
        do
            if [ -e "${root_file}.${branch}" ];then
                mount_move ${sfs_root_mpath}.${branch} ${new_root}
                continue
            fi
            break
        done

        mount_move $sfs_home_mpath ${new_root}
        for branch in $(seq 1 $unionfs_max_branch)
        do
            if [ -e "${home_file}.${branch}" ];then
                mount_move ${sfs_home_mpath}.${branch} ${new_root}
                continue
            fi
            break
        done
    fi
}

mount_archives()
{
    if [ -d ${new_root}/var/cache/apt/archives ];then
        mkdir -p ${new_root}/$work_mpath/cache/archives/
        mount --bind ${new_root}/$work_mpath/cache/archives ${new_root}/var/cache/apt/archives
    fi
}

sfsroot_main()
{
    # umask 0077
    init_params
    init_sfs
    mount_root
    mount_home
    mount_swap
    move_to_newroot
    mount_archives
    # umask 0022

    test "$os_name" = "archlinux" && mount_handler='true'

    if $zm_debug;then
        print_param_info
        print_msg "please input y/n for continue."
        read choice
        if [ "$choice" != "y" ];then
            goto_shell
        fi
    fi
}

# for archlinux
run_hook()
{
    sfsroot_main
}

case "$os_name" in
    debian)
        sfsroot_main
        ;;
    archlinux)
        ;;
esac


